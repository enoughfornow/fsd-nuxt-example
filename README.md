<!-- eslint-disable no-irregular-whitespace -->
# Архитектура FE

[**Feature-Sliced Design**](https://feature-sliced.design/ru/) (FSD) — это архитектурная методология для проектирования фронтенд-приложений. Проще говоря, это набор правил и соглашений по организации кода. Главная цель этой методологии — сделать проект понятнее и стабильнее в условиях постоянно меняющихся бизнес-требований.

### [​Слои](https://feature-sliced.design/ru/docs/get-started/overview#layers "Прямая ссылка на этот заголовок")

Слои стандартизированы во всех проектах FSD. Не обязательно использовать все слои, но их названия важны. На данный момент их шесть (сверху вниз):

1.  **App***  — всё, благодаря чему приложение запускается — роутинг, точки входа, глобальные стили, провайдеры и т. д.
2.  **Pages**  (страницы) — полные страницы или большие части страницы при вложенном роутинге.
3.  **Widgets**  (виджеты) — большие самодостаточные куски функциональности или интерфейса, обычно реализующие целый пользовательский сценарий.
4.  **Features**  (фичи) —  _повторно используемые_  реализации целых фич продукта, то есть действий, приносящих бизнес-ценность пользователю.
5.  **Entities**  (сущности) — бизнес-сущности, с которыми работает проект, например  `user`  или  `product`.
6.  **Shared***  — переиспользуемый код, особенно когда он отделён от специфики проекта/бизнеса, хотя это не обязательно.

_* — эти слои,  **App**  и  **Shared**, в отличие от других слоев, не имеют слайсов и состоят из сегментов напрямую._

Фишка слоев в том, что модули на одном слое могут знать только о модулях со слоев строго ниже, и как следствие, импортировать только с них.
|Layer|Can use|Can be used by
|--|--|--|
|app |`shared`, `entities`, `features`, `widgets`, `pages`|`-`|
|pages|`shared`, `entities`, `features`, `widgets`|`app`|
|widgets|`shared`, `entities`, `features`|`pages`, `app`|
|features|`shared`, `entities`|`widgets`, `pages`, `app`|
|entities|`shared`|`features`, `widgets`, `pages`, `app`|
|shared|`-`| `entities`, `features`, `widgets`, `pages`, `app`|

# /src/pages - Слой страниц приложения

**Страница не содержит какаой либо бизнес-логики, это контейнер для отображения!!!**

Страница - это точка входа, площадка на которой расположены разные фичи, виджеты и модели, так же в файлах index расположен роут по которому эта страница доступна, если роут вложенный, то в папку страницы добавляется папка pages с дочерними роутами

У компонентов страницы префикс `P`, например `PHome.vue`

# src/widgets -  слой виджетов

Виджет - это компонент с изолированной бизес-логикой, который можно переиспользовать в разных частях приложения.
Это структура, которая работает "Из коробки" -  то есть просто воткнул куда нужно без лишних манипуляций и виджет отображается.

У виджета могут быть **только пропсы** для кастомизации.
Виджет отдает **только один компонент** во вне, поэтому все виджет реэкспортятся в файле index.ts

Виджет может использовать модели (src/entities) и фичи(src/features)

У компонентов-виджетов префикс `W`, например `WPage`

Отличие от **features**

Получение данных при рендере (initial data fetching)

Для виджетов, которые нуждаются в данных при начальном рендеринге, можно использовать `useFetch` или `useAsyncData`. Эти composables обеспечивают получение данных на стороне сервера (если включен SSR) и предотвращают повторную загрузку данных на клиенте.

Если необходимо на основании полученных при рендере данных делать другие запросы, то можно передать item пропсами в `feature` компонент.

### **Рендеринг**

**Виджеты, реализующие целые пользовательские сценарии, могут использовать гибридный подход: начальный рендеринг на сервере для быстрой загрузки, с последующей гидратацией на клиенте для интерактивности.**

Важно отметить, что Nuxt предоставляет гибкость в выборе стратегии рендеринга, позволяя оптимизировать производительность и пользовательский опыт для каждого конкретного случая.

```html
<script setup lang='ts'>
  import { api } from 'entities/example'
  import { FExample, useExampleStore } from 'features/example'

    const store = useExampleStore()
    await store.getExampleList()

    const storeData = computed(() => store.data) // если используем store
    const { data } = await useFetch(() => api.getExampleList()) // если нет необходимости использовать store

</script>

<template>
  <div
  v-for="item in data"
  :key="item.id"
  >
    <FExample :data="item"/>
  </div>
</template>
```

# src/features - слой с фичами

Фича - это какая то полезная пользователю функция приложения, зачастую такая функция может быть "размазана" по разным страницам, виджетам

Фича содержит в себе взаимодействие различных моделей(src/entities), у фичи может быть свое хранилище для сохранения состояния и взаимодействия с фичей, в фиче могут быть расположены различные компоненты которые касаются этой фичи

У компонентов-фичей префикс `F`, например `FAuth`

Отличие от **widgets**

В `features` данные с сервера можно получить только по действию юзера(обработчику события).

Когда нужно сделать сетевой запрос на основе взаимодействия с пользователем необходимо использовать [`$fetch`](https://nuxt.com/docs/getting-started/data-fetching#fetch). Подробнее в видео [`Nuxt 3. You are using useFetch WRONG!`](https://www.youtube.com/watch?v=njsGVmcWviY)

Это подтверждается в документации Nuxt: Docs > Getting-started > [Data Fetching](https://nuxt.com/docs/getting-started/data-fetching)

useFetch предназначен для использования в setup-функции компонента, плагине или middleware маршрута. Он не предназначен для использования в обработчиках событий.
useFetch следует использовать на уровне setup-функции компонента для начальной загрузки данных.

### **Рендеринг**

**Фичи, приносящие бизнес-ценность, могут быть разделены: критичные для SEO части рендерятся на сервере, а интерактивные элементы - на клиенте.**

**Начальный рендеринг:**
Хотя данные будут загружаться на клиенте, начальная структура ваших features может быть отрендерена на сервере. Это может улучшить начальное время загрузки и SEO.

**Гидратация:**
После начального рендеринга на сервере, компоненты будут гидратированы на клиенте, что позволит им реагировать на действия пользователя и загружать данные.

Таким образом, ваш подход к features, где данные загружаются только по действию пользователя, приводит к тому, что основная логика и рендеринг данных происходят на клиенте. Однако, это не исключает возможности начального рендеринга структуры компонентов на сервере для оптимизации производительности.

Важно отметить, что Nuxt предоставляет гибкость в выборе стратегии рендеринга, позволяя оптимизировать производительность и пользовательский опыт для каждого конкретного случая.

```html
<script setup lang='ts'>
import { ref } from 'vue'
import useDebounce from '@/composables' // или что-то из vueuse

const classes = {
  root: 'flex flex-col'
}

const searchQuery = ref('')
const searchResults = ref([])
const searched = ref(false)

const debouncedSearch = useDebounce(async () => {
  if (searchQuery.value.length > 2) {
    const results = await $fetch('/api/search', {
      method: 'POST',
      body: { query: searchQuery.value }
    })
    searchResults.value = results
    searched.value = true
  } else {
    searchResults.value = []
    searched.value = false
  }
}, 300)
</script>

<!-- features/FProductSearch.client.vue -->
<template>
  <div :class="classes.root">
    <UIInput
      v-model="searchQuery"
      @input="debouncedSearch"
      placeholder="Поиск товаров..."
    />
    <ul v-if="searchResults.length">
      <VProduct
        v-for="product in searchResults"
        :key="product.id"
      >
        {{ product.name }} - {{ product.price }}
      </VProduct>
    </ul>
    <VProductNotFound
        v-else-if="searched">
      Ничего не найдено
    </VProductNotFound>
  </div>
</template>
```

# src/entities - слой моделей.

Модель - это структура, которая описывает определенную бизнес-сущность. В самой по себе модели **отсутствует какая либо бизнес-логика** Модель может содержать:

- методы апи( но без обращени к этим методам! только описание);
- компоненты для отображения этой бизнес сущности
- типы и интерфейсы описывающие сущность

**Модель содержит только описание бизнес-сущности без какого либо взаимодействия с системой!**

Отображение модели (Model View) - это компонент который "показывает", как выглядит данная сущность.
 Все компоненты отображения модели должны иметь префикс `V`(view),
 например `entities/product/VProductCard`, `entities/auth/VAuthButton`, `entities/user/VUserAvatar` - представление - "карточка товара, кнопка авторизации, аватар юзера"

 **entities** - слой моделей
 **product** - бизнес-сущность
 **product/api** - описание взаимодействия с API
 **product/types** - типы описывающие бизнес-сущность
 **product/ui/VProductCard** - отображение бизнес-сущности

 **у модели может быть множество компонентов для отображения, но они должны относиться только к описываемой бизнес-сущности**

<!-- src/
├── entities/
│   ├── User/
│   │   ├── api.ts
│   │   ├── types.ts
│   │   └── ui/VUserProfile.vue -->

# src/shared - слой, в котором расположены утилиты, юай-компоненты, стили, хуки и т.п, то есть всё то, что никак не затрагивает бизнес-логику приложения

Всё, что есть в слое shared может использоваться **в любой** точке проекта, этот слой **не должен содержать и малейшей части бизнес-логики приложения**

# FE Vue SSR Framework

[**Nuxt**](https://nuxt.com)

# CSS

UnoCSS - это атомарный CSS-движок, который оптимизирует использование классов в проекте. Рассмотрим ключевые аспекты:

1. Атомарные классы

UnoCSS создает атомарные (единичные) классы CSS, которые можно переиспользовать во всем проекте.
Это значительно уменьшает размер итогового CSS-файла.

2. Отсутствие конфликтов

Благодаря атомарному подходу, классы UnoCSS не конфликтуют друг с другом.
Каждый класс отвечает за одно конкретное свойство CSS.

3. Специфичность

UnoCSS не нарушает специфичность CSS.
Все атомарные классы имеют одинаковую специфичность,
что упрощает их использование и предсказуемость.

4. Оптимизация

UnoCSS автоматически генерирует только те классы, которые фактически используются в проекте,
что помогает оптимизировать размер итогового CSS.

**Стилизация в компоненте Vue**

Таким образом мы избегаем длинных записей классов, разделяя их на группы

```html
<script setup lang="ts">
const classes = {
  root: [
    'flex flex-col', // display
    'justify-center items-center', // position
    'border-solid border-black rounded', // border
    'w-max-content', // width
    'p-4 m-0 m-auto', // padding/margin
  ],
  text: 'text-red text-center',
  buttonsContainer: 'flex gap-2 w-full justify-center', // в данном месте классы читаемы, не обязательно разделять
  button: 'w-max-content',
};
</script>
```

# Структура компонента Vue с Composition API

**Для обеспечения согласованности и читаемости кода, следуйте этой структуре при создании компонентов Vue с использованием Composition API:**

1. Типизация пропсов и эмитов
2. Определение пропсов и эмитов
3. Стилизация (если используются объекты классов)
4. Реактивные переменные
5. Вычисляемые свойства
6. Методы
7. Хуки жизненного цикла
8. Отслеживание изменений (watch)

```html
<script setup lang="ts">
// типизация пропсов
interface IProps {
  prop: unknown
}
// типизация эмитов(событий)
interface IEmits {
  (e: 'event', payload: unknown): void
}

const props = defineProps<IProps>();
const emit = defineEmits<IEmits>();

// стилизация
const classes = {
  root: 'flex flex-col',
};

// реактивная переменная
const reactiveVariale = ref(null);

// импользуем если необходимо кешировать значение или не потерять реактивность
const computedVariable = computed(() => reactiveVariale.value);

// метод
function onClick() {
  console.log('click');
}
// если нужно выполнить какое то действие при монтировании на клиенте
onMounted(() => {
  console.log('mounted');
});
// отслеживание изменений на основании reactiveVariale
watch(reactiveVariale, () => {
  console.log('watch');
});
</script>

<template>
  <div :class="classes.root">
    <h1 @click="emit('event', reactiveVariale)">
      Example Feature
    </h1>
    <button @click="onClick">
      Click
    </button>
  </div>
</template>
```
# State Management

[**Pinia**](https://pinia.vuejs.org/core-concepts/)

**Структура стора Pinia в стиле Composition API**
```js
export const useCounterStore = defineStore('counter', () => {
  // state
  const count = ref(0);
  const name = ref('Eduardo');

  // getters
  const doubleCount = computed(() => count.value * 2);

  // actions
  function increment() {
    count.value++;
  }
  // async actions
  async function asyncIncrement() {
    await new Promise(resolve => setTimeout(resolve, 1000));
    count.value++;
  }

  return {
    count,
    name,
    doubleCount,
    increment,
    asyncIncrement,
  };
});
```

# OpenAPI TS

Необходимо чтобы бекенд генерировал документацию для API через [**Swagger**](https://swagger.io)

[**OpenAPI-fetch**](https://openapi-ts.dev/openapi-fetch/) - это легковесный и типобезопасный клиент для работы с API, который использует вашу схему OpenAPI для автоматической генерации типов и обеспечения правильности запросов. Он идеально подходит для использования в проектах на React, Vue, Svelte и обычном JavaScript, и не влияет на производительность приложения.

**Пример реализации будет позже**
